// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  // Para bancos remotos sem permissão de criar shadow database, descomente a linha abaixo:
  // shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // Opcional: banco temporário para migrations
}

// ============================================
// USERS & AUTHENTICATION
// ============================================

model User {
  id                   Int      @id @default(autoincrement())
  email                String   @unique @db.VarChar(255)
  password_hash        String   @db.Text
  is_active            Boolean  @default(true)
  must_change_password Boolean  @default(false)
  created_at           DateTime @default(now())
  updated_at           DateTime @updatedAt

  profile           Profile?
  roles             UserRole[]
  login_history     LoginHistory[]
  audit_logs        AuditLog[]
  exchange_accounts ExchangeAccount[]
  vaults            Vault[]
  webhook_sources   WebhookSource[]
  trade_parameters  TradeParameter[]
  password_reset_tokens PasswordResetToken[]
  subscriptions     Subscription[]
  subscriber_profile SubscriberProfile?
  subscriber_parameters SubscriberParameters?
  monitor_config WebhookMonitorConfig?
  passkeys Passkey[]
  sessions UserSession[]
  web_push_subscriptions WebPushSubscription[]

  @@index([email])
  @@index([is_active])
  @@map("users")
}

model Profile {
  id                      Int      @id @default(autoincrement())
  user_id                 Int      @unique
  full_name               String?  @db.VarChar(255)
  phone                   String?  @db.VarChar(20)
  whatsapp_phone          String?  @db.VarChar(20)
  position_alerts_enabled Boolean  @default(true)
  twofa_enabled           Boolean  @default(false)
  twofa_secret            String?  @db.VarChar(255)
  created_at              DateTime @default(now())
  updated_at              DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model UserRole {
  id      Int    @id @default(autoincrement())
  user_id Int
  role    String @db.VarChar(50) // 'admin' | 'user'

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, role])
  @@index([user_id])
  @@map("user_roles")
}

model LoginHistory {
  id         Int      @id @default(autoincrement())
  user_id    Int
  ip         String?  @db.VarChar(45)
  user_agent String?  @db.Text
  success    Boolean
  created_at DateTime @default(now())

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([created_at])
  @@map("login_history")
}

model AuditLog {
  id           Int      @id @default(autoincrement())
  user_id      Int?
  entity_type  String   @db.VarChar(50)
  entity_id    Int?
  action       String   @db.VarChar(50)
  changes_json Json?    @db.Json
  ip           String?  @db.VarChar(45)
  user_agent   String?  @db.Text
  request_id   String?  @db.VarChar(255)
  created_at   DateTime @default(now())

  user User? @relation(fields: [user_id], references: [id], onDelete: SetNull)

  @@index([user_id])
  @@index([entity_type, entity_id])
  @@index([created_at])
  @@map("audit_logs")
}

model SystemAuditLog {
  id            Int      @id @default(autoincrement())
  service       String   @db.VarChar(50) // 'API' | 'EXECUTOR' | 'MONITORS'
  event_type    String   @db.VarChar(100)
  entity_type   String?  @db.VarChar(50)
  entity_id     Int?
  severity      String   @db.VarChar(20) // 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL'
  message       String   @db.Text
  metadata_json Json?    @db.Json
  created_at    DateTime @default(now())

  @@index([service, created_at])
  @@index([severity, created_at])
  @@map("system_audit_logs")
}

// ============================================
// EXCHANGE ACCOUNTS
// ============================================

model ExchangeAccount {
  id                    Int      @id @default(autoincrement())
  user_id               Int
  exchange              String   @db.VarChar(50) // 'BINANCE_SPOT', 'BINANCE_FUTURES', etc
  label                 String   @db.VarChar(255)
  is_simulation         Boolean  @default(false)
  api_key_enc           String?  @db.Text
  api_secret_enc        String?  @db.Text
  proxy_url             String?  @db.VarChar(500)
  testnet               Boolean  @default(false)
  is_active             Boolean  @default(true)
  initial_balances_json Json?    @db.Json
  fee_rate_buy_limit    Decimal? @db.Decimal(10, 8) // Taxa para compra limit (ex: 0.001 = 0.1%)
  fee_rate_buy_market    Decimal? @db.Decimal(10, 8) // Taxa para compra market
  fee_rate_sell_limit   Decimal? @db.Decimal(10, 8) // Taxa para venda limit
  fee_rate_sell_market   Decimal? @db.Decimal(10, 8) // Taxa para venda market
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt

  user             User                    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  balances_cache   AccountBalanceCache[]
  webhook_bindings AccountWebhookBinding[]
  trade_parameters TradeParameter[]
  trade_jobs       TradeJob[]
  trade_executions TradeExecution[]
  positions        TradePosition[]
  monitor_alerts   WebhookMonitorAlert[]

  @@index([user_id])
  @@index([user_id, id])
  @@index([is_simulation])
  @@map("exchange_accounts")
}

model AccountBalanceCache {
  id                  Int       @id @default(autoincrement())
  exchange_account_id Int
  trade_mode          String    @db.VarChar(20) // 'REAL' | 'SIMULATION'
  asset               String    @db.VarChar(20)
  free                Decimal   @db.Decimal(36, 18)
  locked              Decimal   @db.Decimal(36, 18)
  last_sync_at        DateTime? @default(now())

  exchange_account ExchangeAccount @relation(fields: [exchange_account_id], references: [id], onDelete: Cascade)

  @@unique([exchange_account_id, trade_mode, asset])
  @@index([exchange_account_id, trade_mode])
  @@map("account_balances_cache")
}

// ============================================
// VAULTS
// ============================================

model Vault {
  id          Int      @id @default(autoincrement())
  user_id     Int
  name        String   @db.VarChar(255)
  description String?  @db.Text
  trade_mode  String   @db.VarChar(20) // 'REAL' | 'SIMULATION'
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  user             User               @relation(fields: [user_id], references: [id], onDelete: Cascade)
  balances         VaultBalance[]
  transactions     VaultTransaction[]
  trade_parameters TradeParameter[]

  @@index([user_id])
  @@index([trade_mode])
  @@map("vaults")
}

model VaultBalance {
  id         Int      @id @default(autoincrement())
  vault_id   Int
  asset      String   @db.VarChar(20)
  balance    Decimal  @default(0) @db.Decimal(36, 18)
  reserved   Decimal  @default(0) @db.Decimal(36, 18)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  vault Vault @relation(fields: [vault_id], references: [id], onDelete: Cascade)

  @@unique([vault_id, asset])
  @@index([vault_id])
  @@map("vault_balances")
}

model VaultTransaction {
  id           Int      @id @default(autoincrement())
  vault_id     Int
  type         String   @db.VarChar(50) // 'DEPOSIT', 'WITHDRAWAL', 'BUY_RESERVE', etc
  asset        String   @db.VarChar(20)
  amount       Decimal  @db.Decimal(36, 18)
  trade_job_id Int?
  meta_json    Json?    @db.Json
  created_at   DateTime @default(now())

  vault Vault @relation(fields: [vault_id], references: [id], onDelete: Cascade)

  @@index([vault_id])
  @@index([created_at])
  @@map("vault_transactions")
}

// ============================================
// TRADE PARAMETERS
// ============================================

model TradeParameter {
  id                       Int      @id @default(autoincrement())
  user_id                  Int
  exchange_account_id      Int
  symbol                   String   @db.VarChar(200)
  side                     String   @db.VarChar(10) // 'BUY' | 'SELL' | 'BOTH'
  quote_amount_fixed       Decimal? @db.Decimal(36, 18)
  quote_amount_pct_balance Decimal? @db.Decimal(5, 2)
  max_orders_per_hour      Int?
  min_interval_sec         Int?
  order_type_default       String   @default("MARKET") @db.VarChar(20)
  slippage_bps             Int      @default(0)
  default_sl_enabled       Boolean  @default(false)
  default_sl_pct           Decimal? @db.Decimal(5, 2)
  default_tp_enabled       Boolean  @default(false)
  default_tp_pct           Decimal? @db.Decimal(5, 2)
  default_sg_enabled       Boolean  @default(false)
  default_sg_pct           Decimal? @db.Decimal(5, 2)
  default_sg_drop_pct      Decimal? @db.Decimal(5, 2)
  default_tsg_enabled      Boolean  @default(false)
  default_tsg_activation_pct Decimal? @db.Decimal(5, 2)
  default_tsg_drop_pct     Decimal? @db.Decimal(5, 2)
  trailing_stop_enabled    Boolean  @default(false)
  trailing_distance_pct    Decimal? @db.Decimal(5, 2)
  min_profit_pct           Decimal? @db.Decimal(5, 2)
  group_positions_enabled  Boolean  @default(false)
  group_positions_interval_minutes Int?
  vault_id                 Int?
  created_at               DateTime @default(now())
  updated_at               DateTime @updatedAt

  user             User            @relation(fields: [user_id], references: [id], onDelete: Cascade)
  exchange_account ExchangeAccount @relation(fields: [exchange_account_id], references: [id], onDelete: Cascade)
  vault            Vault?          @relation(fields: [vault_id], references: [id], onDelete: SetNull)

  @@index([exchange_account_id, symbol])
  @@map("trade_parameters")
}

// ============================================
// WEBHOOKS
// ============================================

model WebhookSource {
  id                  Int      @id @default(autoincrement())
  owner_user_id       Int
  label               String   @db.VarChar(255)
  webhook_code        String   @unique @db.VarChar(100)
  trade_mode          String   @db.VarChar(20) // 'REAL' | 'SIMULATION'
  allowed_ips_json    Json?    @db.Json
  require_signature   Boolean  @default(false)
  signing_secret_enc  String?  @db.Text
  rate_limit_per_min  Int      @default(60)
  is_active           Boolean  @default(true)
  is_shared           Boolean  @default(false)
  admin_locked        Boolean  @default(false)
  is_subscriber_webhook Boolean @default(false)
  alert_group_enabled Boolean  @default(false)
  alert_group_id      String?  @db.VarChar(255)
  monitor_enabled     Boolean  @default(false)
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  user             User                    @relation(fields: [owner_user_id], references: [id], onDelete: Cascade)
  bindings         AccountWebhookBinding[]
  events           WebhookEvent[]
  blocked_attempts WebhookBlockedAttempt[]
  monitor_alerts   WebhookMonitorAlert[]

  @@index([webhook_code])
  @@index([owner_user_id])
  @@map("webhook_sources")
}

model AccountWebhookBinding {
  id                  Int      @id @default(autoincrement())
  webhook_source_id   Int
  exchange_account_id Int
  is_active           Boolean  @default(true)
  weight              Decimal? @default(1) @db.Decimal(5, 2)
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  webhook_source   WebhookSource   @relation(fields: [webhook_source_id], references: [id], onDelete: Cascade)
  exchange_account ExchangeAccount @relation(fields: [exchange_account_id], references: [id], onDelete: Cascade)

  @@unique([webhook_source_id, exchange_account_id])
  @@index([webhook_source_id])
  @@map("account_webhook_bindings")
}

model WebhookEvent {
  id                Int       @id @default(autoincrement())
  webhook_source_id Int
  target_account_id Int
  trade_mode        String    @db.VarChar(20)
  event_uid         String    @db.VarChar(255)
  symbol_raw        String    @db.VarChar(100)
  symbol_normalized String    @db.VarChar(100)
  action            String    @db.VarChar(50) // 'BUY_SIGNAL' | 'SELL_SIGNAL' | 'UNKNOWN'
  timeframe         String?   @db.VarChar(10)
  price_reference   Decimal?  @db.Decimal(36, 18)
  raw_text          String?   @db.Text
  raw_payload_json  Json?     @db.Json
  status            String    @default("RECEIVED") @db.VarChar(50) // 'RECEIVED' | 'MONITORING' | 'JOB_CREATED' | 'SKIPPED' | 'FAILED' | 'REPLACED'
  validation_error  String?   @db.Text
  created_at        DateTime  @default(now())
  processed_at      DateTime?

  webhook_source WebhookSource @relation(fields: [webhook_source_id], references: [id], onDelete: Cascade)
  monitor_alerts WebhookMonitorAlert[] @relation("WebhookEventMonitorAlert")

  @@unique([webhook_source_id, event_uid, target_account_id])
  @@index([webhook_source_id])
  @@index([target_account_id])
  @@index([status])
  @@index([created_at])
  @@map("webhook_events")
}

model WebhookBlockedAttempt {
  id                Int      @id @default(autoincrement())
  webhook_source_id Int
  ip                String   @db.VarChar(45)
  reason            String   @db.VarChar(100)
  created_at        DateTime @default(now())

  webhook_source WebhookSource @relation(fields: [webhook_source_id], references: [id], onDelete: Cascade)

  @@index([webhook_source_id])
  @@index([created_at])
  @@map("webhook_blocked_attempts")
}

// ============================================
// WEBHOOK MONITOR
// ============================================

model WebhookMonitorAlert {
  id                      Int       @id @default(autoincrement())
  webhook_source_id       Int
  webhook_event_id         Int
  exchange_account_id     Int?      // Opcional: mantido para referência, mas não é mais parte da chave única
  symbol                   String    @db.VarChar(50)
  trade_mode               String    @db.VarChar(20) // 'REAL' | 'SIMULATION'
  side                     String    @default("BUY") @db.VarChar(10) // 'BUY' | 'SELL'
  price_alert              Decimal   @db.Decimal(36, 18)
  price_original           Decimal?  @db.Decimal(36, 18) // Preço com que ESTE alerta foi criado
  price_first_alert        Decimal?  @db.Decimal(36, 18) // Preço do PRIMEIRO alerta da cadeia (herdado quando substituído)
  price_minimum            Decimal?  @db.Decimal(36, 18) // Para BUY: menor preço visto
  price_maximum            Decimal?  @db.Decimal(36, 18) // Para SELL: maior preço visto
  current_price            Decimal?  @db.Decimal(36, 18)
  execution_price          Decimal?  @db.Decimal(36, 18) // Preço quando foi executado
  state                    String    @default("MONITORING") @db.VarChar(50) // 'MONITORING' | 'EXECUTED' | 'CANCELLED'
  monitoring_status        String?   @db.VarChar(20) // 'FALLING' | 'LATERAL' | 'RISING'
  cycles_without_new_low  Int       @default(0) // Para BUY: ciclos sem novo fundo
  cycles_without_new_high Int       @default(0) // Para SELL: ciclos sem novo topo
  last_price_check_at      DateTime?
  executed_trade_job_id    Int?     // Primeiro job ID (mantido para compatibilidade)
  executed_trade_job_ids_json Json? // Array de todos os job IDs criados
  cancel_reason            String?   @db.Text
  exit_reason              String?   @db.VarChar(100) // Motivo de saída: 'EXECUTED', 'CANCELLED', 'MAX_FALL', 'MAX_TIME', etc.
  exit_details             String?   @db.Text // Detalhes do motivo (ex: "Lateralizado por 5 ciclos", "Em alta por 3 ciclos")
  monitoring_duration_minutes Int?   // Tempo total em monitoramento (minutos)
  savings_pct                 Decimal?  @db.Decimal(10, 4) // % economia vs preço alerta inicial
  efficiency_pct              Decimal?  @db.Decimal(10, 4) // % proximidade do melhor preço (min/max)
  replaced_alert_id        Int?      // ID do alerta que este substituiu (para rastreabilidade da cadeia)
  replacement_count        Int       @default(0) // Contador de quantos alertas foram substituídos na cadeia
  created_at               DateTime  @default(now())
  updated_at               DateTime  @updatedAt

  webhook_source   WebhookSource   @relation(fields: [webhook_source_id], references: [id], onDelete: Cascade)
  webhook_event    WebhookEvent   @relation("WebhookEventMonitorAlert", fields: [webhook_event_id], references: [id], onDelete: Cascade)
  exchange_account ExchangeAccount? @relation(fields: [exchange_account_id], references: [id], onDelete: Cascade)
  snapshots        WebhookMonitorSnapshot[]

  @@index([webhook_source_id])
  @@index([webhook_source_id, symbol, trade_mode, state], name: "wh_monitor_alerts_active_idx")
  @@index([state])
  @@index([side])
  @@index([created_at])
  @@index([replaced_alert_id])
  @@map("webhook_monitor_alerts")
}

model WebhookMonitorConfig {
  id                          Int      @id @default(autoincrement())
  user_id                     Int?     // null = configuração global
  monitor_enabled             Boolean  @default(true)
  check_interval_sec          Int      @default(30)
  
  // Parâmetros para BUY
  lateral_tolerance_pct        Decimal  @default(0.3) @db.Decimal(5, 2)
  lateral_cycles_min          Int      @default(4)
  lateral_cycles_enabled      Boolean  @default(true) // Se false, ignora lateral_cycles_min
  rise_trigger_pct            Decimal  @default(0.75) @db.Decimal(5, 2)
  rise_cycles_min             Int      @default(2)
  rise_cycles_enabled         Boolean  @default(true) // Se false, ignora rise_cycles_min
  max_fall_pct                Decimal  @default(6.0) @db.Decimal(5, 2)
  max_fall_enabled            Boolean  @default(false) // Se false, não cancela por queda máxima
  max_monitoring_time_min     Int      @default(60)
  max_monitoring_time_enabled Boolean  @default(false) // Se false, não cancela por tempo máximo
  cooldown_after_execution_min Int     @default(30)
  
  // Parâmetros para SELL
  sell_lateral_tolerance_pct   Decimal  @default(0.3) @db.Decimal(5, 2)
  sell_lateral_cycles_min      Int      @default(4)
  sell_lateral_cycles_enabled  Boolean  @default(true) // Se false, ignora sell_lateral_cycles_min
  sell_fall_trigger_pct        Decimal  @default(0.5) @db.Decimal(5, 2) // Quando considerar "caindo" para executar
  sell_fall_cycles_min         Int      @default(2)
  sell_fall_cycles_enabled     Boolean  @default(true) // Se false, ignora sell_fall_cycles_min
  sell_max_rise_pct            Decimal  @default(6.0) @db.Decimal(5, 2) // DEPRECADO: Não faz sentido cancelar venda se preço sobe (mais lucro). Mantido apenas para compatibilidade.
  sell_max_monitoring_time_min Int      @default(60)
  sell_max_monitoring_time_enabled Boolean @default(false) // Se false, não cancela por tempo máximo
  sell_cooldown_after_execution_min Int @default(30)
  
  created_at                  DateTime @default(now())
  updated_at                  DateTime @updatedAt

  user User? @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id])
  @@index([user_id])
  @@map("webhook_monitor_config")
}

model WebhookMonitorSnapshot {
  id                      Int       @id @default(autoincrement())
  alert_id                Int
  event_type              String    @db.VarChar(50) // 'CREATED' | 'PRICE_CHECK' | 'STATUS_CHANGE' | 'REPLACED' | 'EXECUTED' | 'CANCELLED'
  monitoring_status       String?   @db.VarChar(20) // 'FALLING' | 'LATERAL' | 'RISING'
  current_price           Decimal?  @db.Decimal(36, 18)
  price_minimum           Decimal?  @db.Decimal(36, 18)
  price_maximum           Decimal?  @db.Decimal(36, 18)
  cycles_without_new_low  Int?
  cycles_without_new_high Int?
  details                 Json?     // Dados extras como: replaced_by_alert_id, cancel_reason, etc
  created_at              DateTime  @default(now())

  alert WebhookMonitorAlert @relation(fields: [alert_id], references: [id], onDelete: Cascade)

  @@index([alert_id, created_at])
  @@map("webhook_monitor_snapshots")
}

// ============================================
// TRADE JOBS & EXECUTIONS
// ============================================

model TradeJob {
  id                     Int       @id @default(autoincrement())
  webhook_event_id       Int?
  exchange_account_id    Int
  trade_mode             String    @db.VarChar(20)
  symbol                 String    @db.VarChar(50)
  side                   String    @db.VarChar(10) // 'BUY' | 'SELL'
  order_type             String    @default("MARKET") @db.VarChar(20)
  quote_amount           Decimal?  @db.Decimal(36, 18)
  base_quantity          Decimal?  @db.Decimal(36, 18)
  limit_price            Decimal?  @db.Decimal(36, 18)
  status                 String    @default("PENDING") @db.VarChar(50)
  reason_code            String?   @db.VarChar(100)
  reason_message         String?   @db.Text
  vault_id               Int?
  limit_order_expires_at DateTime?
  position_id_to_close   Int?      // Posição específica a fechar (para SELL)
  created_by             String?   @db.VarChar(50) // Quem ou qual serviço criou a ordem (USER_MANUAL, WEBHOOK, SLTP_MONITOR, etc.)
  created_at             DateTime  @default(now())
  updated_at             DateTime  @updatedAt

  exchange_account ExchangeAccount  @relation(fields: [exchange_account_id], references: [id], onDelete: Cascade)
  executions       TradeExecution[]
  position_open    TradePosition?   @relation("PositionOpenJob")
  position_to_close TradePosition?  @relation("PositionCloseJob", fields: [position_id_to_close], references: [id], onDelete: SetNull)
  grouped_in       PositionGroupedJob[]

  @@index([exchange_account_id, status])
  @@index([status])
  @@index([trade_mode])
  @@index([created_at])
  @@index([position_id_to_close])
  @@map("trade_jobs")
}

model TradeExecution {
  id                  Int      @id @default(autoincrement())
  trade_job_id        Int
  exchange_account_id Int
  trade_mode          String   @db.VarChar(20)
  exchange            String   @db.VarChar(50)
  exchange_order_id   String?  @db.VarChar(255)
  client_order_id     String   @db.VarChar(255)
  status_exchange     String   @db.VarChar(50)
  executed_qty        Decimal  @db.Decimal(36, 18)
  cumm_quote_qty      Decimal  @db.Decimal(36, 18)
  avg_price           Decimal  @db.Decimal(36, 18)
  fee_amount          Decimal? @db.Decimal(36, 18)
  fee_currency        String?  @db.VarChar(20)
  fee_rate            Decimal? @db.Decimal(10, 8)
  fills_json          Json?    @db.Json
  raw_response_json   Json?    @db.Json
  created_at          DateTime @default(now())

  trade_job        TradeJob        @relation(fields: [trade_job_id], references: [id], onDelete: Cascade)
  exchange_account ExchangeAccount @relation(fields: [exchange_account_id], references: [id], onDelete: Cascade)
  position_fills   PositionFill[]

  @@index([trade_job_id])
  @@index([exchange_account_id])
  @@index([trade_mode])
  @@index([created_at])
  @@map("trade_executions")
}

// ============================================
// POSITIONS
// ============================================

model TradePosition {
  id                    Int       @id @default(autoincrement())
  exchange_account_id   Int
  trade_mode            String    @db.VarChar(20)
  symbol                String    @db.VarChar(50)
  side                  String    @default("LONG") @db.VarChar(10)
  trade_job_id_open     Int
  qty_total             Decimal   @db.Decimal(36, 18)
  qty_remaining         Decimal   @db.Decimal(36, 18)
  price_open            Decimal   @db.Decimal(36, 18)
  status                String    @default("OPEN") @db.VarChar(20)
  realized_profit_usd   Decimal   @default(0) @db.Decimal(36, 18)
  total_fees_paid_usd   Decimal   @default(0) @db.Decimal(36, 18)
  fees_on_buy_usd       Decimal   @default(0) @db.Decimal(36, 18)
  fees_on_sell_usd      Decimal   @default(0) @db.Decimal(36, 18)
  sl_enabled            Boolean   @default(false)
  sl_pct                Decimal?  @db.Decimal(5, 2)
  tp_enabled            Boolean   @default(false)
  tp_pct                Decimal?  @db.Decimal(5, 2)
  sg_enabled            Boolean   @default(false)
  sg_pct                Decimal?  @db.Decimal(5, 2)
  sg_drop_pct           Decimal?  @db.Decimal(5, 2)
  sg_activated          Boolean   @default(false)
  trailing_enabled      Boolean   @default(false)
  trailing_distance_pct Decimal?  @db.Decimal(5, 2)
  trailing_max_price    Decimal?  @db.Decimal(36, 18)
  min_profit_pct        Decimal?  @db.Decimal(5, 2)
  sl_triggered          Boolean   @default(false)
  tp_triggered          Boolean   @default(false)
  sg_triggered          Boolean   @default(false)
  tsg_enabled           Boolean   @default(false)
  tsg_activation_pct    Decimal?  @db.Decimal(5, 2)
  tsg_drop_pct          Decimal?  @db.Decimal(5, 2)
  tsg_activated         Boolean   @default(false)
  tsg_max_pnl_pct       Decimal?  @db.Decimal(5, 2)
  tsg_triggered         Boolean   @default(false)
  trailing_triggered    Boolean   @default(false)
  partial_tp_triggered  Boolean   @default(false)
  lock_sell_by_webhook  Boolean   @default(false)
  is_grouped            Boolean   @default(false)
  group_started_at      DateTime?
  is_dust               Boolean   @default(false)
  dust_value_usd        Decimal?  @db.Decimal(36, 18)
  original_position_id  Int?
  close_reason          String?   @db.VarChar(50)
  closed_at             DateTime?
  // ✅ NOVO: Sistema de resíduos
  is_residue_position   Boolean   @default(false) @map("is_residue_position")
  parent_position_id    Int?                     @map("parent_position_id")
  created_at            DateTime  @default(now())
  updated_at            DateTime  @updatedAt

  exchange_account ExchangeAccount @relation(fields: [exchange_account_id], references: [id], onDelete: Cascade)
  open_job         TradeJob        @relation("PositionOpenJob", fields: [trade_job_id_open], references: [id])
  close_jobs       TradeJob[]      @relation("PositionCloseJob")
  original_position TradePosition?  @relation("DustOriginalPosition", fields: [original_position_id], references: [id])
  dust_positions   TradePosition[] @relation("DustOriginalPosition")
  // ✅ NOVO: Relações de resíduo
  parent_position   TradePosition?  @relation("ResidueMoves", fields: [parent_position_id], references: [id])
  residue_moves     TradePosition[] @relation("ResidueMoves")
  residue_transfers_out ResidueTransferJob[] @relation("ResidueSource")
  residue_transfers_in  ResidueTransferJob[] @relation("ResidueTarget")
  fills            PositionFill[]
  grouped_jobs     PositionGroupedJob[]

  @@unique([trade_job_id_open])
  @@index([exchange_account_id, symbol, status])
  @@index([exchange_account_id, trade_mode, symbol, status, is_grouped, created_at], name: "trade_positions_grouping_idx")
  @@index([status])
  @@index([trade_mode])
  @@index([created_at])
  @@index([is_dust])
  @@index([original_position_id])
  @@index([is_residue_position])
  @@map("trade_positions")
}

model PositionFill {
  id                 Int      @id @default(autoincrement())
  position_id        Int
  trade_execution_id Int
  side               String   @db.VarChar(10) // 'BUY' | 'SELL'
  qty                Decimal  @db.Decimal(36, 18)
  price              Decimal  @db.Decimal(36, 18)
  created_at         DateTime @default(now())

  position  TradePosition  @relation(fields: [position_id], references: [id], onDelete: Cascade)
  execution TradeExecution @relation(fields: [trade_execution_id], references: [id], onDelete: Cascade)

  @@index([position_id])
  @@index([trade_execution_id])
  @@map("position_fills")
}

model PositionGroupedJob {
  id           Int      @id @default(autoincrement())
  position_id  Int
  trade_job_id Int
  created_at   DateTime @default(now())

  position TradePosition @relation(fields: [position_id], references: [id], onDelete: Cascade)
  trade_job TradeJob     @relation(fields: [trade_job_id], references: [id], onDelete: Cascade)

  @@unique([position_id, trade_job_id])
  @@index([position_id])
  @@index([trade_job_id])
  @@map("position_grouped_jobs")
}

// ✅ NOVO: Job de transferência de resíduo
model ResidueTransferJob {
  id                    Int      @id @default(autoincrement())
  source_position_id    Int      @map("source_position_id")
  target_position_id    Int?     @map("target_position_id")
  symbol                String   @db.VarChar(50)
  qty_transferred       Decimal  @db.Decimal(36, 18) @map("qty_transferred")
  status                String   @db.VarChar(50) // PENDING, COMPLETED, FAILED
  reason_message        String?  @db.Text @map("reason_message")
  created_at            DateTime @default(now()) @map("created_at")
  completed_at          DateTime? @map("completed_at")
  
  source_position TradePosition @relation("ResidueSource", fields: [source_position_id], references: [id])
  target_position TradePosition? @relation("ResidueTarget", fields: [target_position_id], references: [id])
  
  @@index([status])
  @@index([source_position_id])
  @@map("residue_transfer_jobs")
}

// ============================================
// NOTIFICATIONS
// ============================================

model WhatsAppGlobalConfig {
  id            Int      @id @default(autoincrement())
  api_url       String   @db.VarChar(500)
  api_key       String?  @db.VarChar(255)
  instance_name String   @db.VarChar(100)
  is_active     Boolean  @default(false)
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  @@map("whatsapp_global_config")
}

model WhatsAppNotificationsConfig {
  id                      Int      @id @default(autoincrement())
  user_id                 Int      @unique
  position_opened_enabled Boolean  @default(true)
  position_closed_enabled Boolean  @default(true)
  stop_loss_enabled       Boolean  @default(true)
  take_profit_enabled     Boolean  @default(true)
  vault_alerts_enabled    Boolean  @default(false)
  created_at              DateTime @default(now())
  updated_at              DateTime @updatedAt

  @@map("whatsapp_notifications_config")
}

model PositionAlertSent {
  id          Int      @id @default(autoincrement())
  position_id Int
  alert_type  String   @db.VarChar(50)
  sent_at     DateTime @default(now())

  @@unique([position_id, alert_type])
  @@index([position_id])
  @@map("position_alerts_sent")
}

model VaultAlertSent {
  id         Int      @id @default(autoincrement())
  vault_id   Int
  alert_type String   @db.VarChar(50)
  sent_at    DateTime @default(now())

  @@unique([vault_id, alert_type, sent_at])
  @@index([vault_id])
  @@map("vault_alerts_sent")
}

model WhatsAppNotificationTemplate {
  id             Int      @id @default(autoincrement())
  template_type  String   @db.VarChar(50) // 'WEBHOOK_RECEIVED', 'TEST_MESSAGE', 'POSITION_OPENED', 'POSITION_CLOSED', 'STOP_LOSS_TRIGGERED', 'PARTIAL_TP_TRIGGERED'
  name           String   @db.VarChar(255)
  subject        String?  @db.VarChar(255)
  body           String   @db.Text
  variables_json Json?    @db.Json
  is_active      Boolean  @default(true)
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  @@index([template_type, is_active])
  @@index([template_type])
  @@map("whatsapp_notification_templates")
}

model WhatsAppNotificationLog {
  id               Int      @id @default(autoincrement())
  template_type    String   @db.VarChar(50) // Tipo de template usado
  recipient        String   @db.VarChar(255) // Número de telefone ou grupo ID
  recipient_type   String   @db.VarChar(20) // 'phone' | 'group'
  message          String?  @db.Text // Mensagem enviada (opcional, pode ser null para economizar espaço)
  status           String   @db.VarChar(20) // 'sent' | 'failed'
  error_message    String?  @db.Text // Mensagem de erro se falhou
  webhook_event_id Int? // ID do evento de webhook se aplicável
  position_id      Int? // ID da posição se aplicável
  vault_id         Int? // ID do cofre se aplicável
  sent_at          DateTime @default(now())

  @@index([template_type])
  @@index([recipient])
  @@index([sent_at])
  @@index([status])
  @@index([webhook_event_id])
  @@index([position_id])
  @@map("whatsapp_notification_logs")
}

// ============================================
// EMAIL NOTIFICATIONS
// ============================================

model PasswordResetToken {
  id         Int       @id @default(autoincrement())
  user_id    Int
  token      String    @unique @db.VarChar(255)
  expires_at DateTime
  used_at    DateTime?
  created_at DateTime  @default(now())

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([token])
  @@index([expires_at])
  @@map("password_reset_tokens")
}

model EmailNotificationLog {
  id            Int       @id @default(autoincrement())
  template_type String    @db.VarChar(50) // 'PASSWORD_RESET', 'SYSTEM_ALERT', 'POSITION_OPENED', etc
  recipient     String    @db.VarChar(255)
  subject       String    @db.VarChar(255)
  status        String    @db.VarChar(20) // 'sent' | 'failed'
  error_message String?   @db.Text
  sent_at       DateTime?

  @@index([template_type])
  @@index([recipient])
  @@index([sent_at])
  @@index([status])
  @@map("email_notification_logs")
}

model EmailNotificationsConfig {
  id                      Int      @id @default(autoincrement())
  user_id                 Int      @unique
  password_reset_enabled  Boolean  @default(true)
  system_alerts_enabled   Boolean  @default(true)
  position_opened_enabled  Boolean  @default(true)
  position_closed_enabled Boolean  @default(true)
  operations_enabled       Boolean  @default(true)
  created_at              DateTime @default(now())
  updated_at               DateTime @updatedAt

  @@map("email_notifications_config")
}

// ============================================
// SYSTEM MONITORING
// ============================================

model SystemMonitoringLog {
  id           Int      @id @default(autoincrement())
  timestamp    DateTime @default(now())
  service_name String   @db.VarChar(50) // 'API', 'EXECUTOR', 'MONITORS'
  process_id   Int?
  status       String   @db.VarChar(20) // 'running', 'stopped', 'error'
  cpu_usage    Decimal? @db.Decimal(5, 2)
  memory_usage Decimal? @db.Decimal(10, 2)
  metrics_json Json?    @db.Json

  @@index([service_name, timestamp])
  @@index([timestamp])
  @@map("system_monitoring_logs")
}

model SystemAlert {
  id            Int       @id @default(autoincrement())
  alert_type    String    @db.VarChar(50) // 'PROCESS_STUCK', 'HIGH_CPU', 'HIGH_MEMORY', 'SERVICE_DOWN'
  severity      String    @db.VarChar(20) // 'low', 'medium', 'high', 'critical'
  message       String    @db.Text
  service_name  String?   @db.VarChar(50)
  metadata_json Json?     @db.Json
  created_at    DateTime  @default(now())
  resolved_at   DateTime?
  resolved_by   Int? // user_id que resolveu o alerta

  @@index([alert_type, severity])
  @@index([created_at])
  @@index([resolved_at])
  @@map("system_alerts")
}

// ============================================
// CRON JOBS MANAGEMENT
// ============================================

model CronJobConfig {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(100) // Nome único do job (ex: 'sl-tp-monitor-real')
  description String   @db.VarChar(255)
  queue_name  String   @db.VarChar(100) // Nome da fila BullMQ
  job_id      String   @db.VarChar(100) // jobId do BullMQ
  interval_ms Int // Intervalo em milissegundos
  status      String   @default("ACTIVE") @db.VarChar(20) // 'ACTIVE', 'PAUSED', 'DISABLED'
  enabled     Boolean  @default(true)
  timeout_ms  Int? // Timeout para execução
  max_retries Int      @default(3)
  config_json Json?    @db.Json // Configurações adicionais
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  updated_by  Int? // user_id que atualizou

  executions CronJobExecution[]

  @@index([name])
  @@index([status])
  @@map("cron_job_configs")
}

model CronJobExecution {
  id            Int       @id @default(autoincrement())
  job_config_id Int
  started_at    DateTime  @default(now())
  finished_at   DateTime?
  duration_ms   Int?
  status        String    @db.VarChar(20) // 'SUCCESS', 'FAILED', 'TIMEOUT', 'RUNNING'
  result_json   Json?     @db.Json
  error_message String?   @db.Text
  triggered_by  String    @default("SCHEDULED") @db.VarChar(20) // 'SCHEDULED', 'MANUAL'

  job_config CronJobConfig @relation(fields: [job_config_id], references: [id], onDelete: Cascade)

  @@index([job_config_id, started_at])
  @@index([started_at])
  @@index([status])
  @@map("cron_job_executions")
}

// ============================================
// MERCADO PAGO CONFIG
// ============================================

model MercadoPagoConfig {
  id                  Int      @id @default(autoincrement())
  access_token_enc    String   @db.Text
  public_key          String   @db.VarChar(255)
  webhook_secret_enc  String?  @db.Text
  environment         String   @default("sandbox") @db.VarChar(20) // 'sandbox' | 'production'
  webhook_url         String?  @db.VarChar(500)
  is_active           Boolean  @default(false)
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  @@map("mercadopago_config")
}

// ============================================
// TRANSFI CONFIG
// ============================================

model TransFiConfig {
  id                    Int      @id @default(autoincrement())
  merchant_id           String   @db.VarChar(255) // MID
  username              String   @db.VarChar(255)
  password_enc          String   @db.Text // Merchant Key (Password) criptografado
  environment           String   @default("sandbox") @db.VarChar(20) // 'sandbox' | 'production'
  webhook_url           String?  @db.VarChar(500)
  redirect_url          String?  @db.VarChar(500)
  webhook_secret_enc    String?  @db.Text
  is_active             Boolean  @default(false)
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt

  @@map("transfi_config")
}

// ============================================
// MVM PAY CONFIG (PARTNER API + CHECKOUT REDIRECT)
// ============================================

model MvmPayConfig {
  id             Int      @id @default(autoincrement())
  base_url       String   @db.VarChar(500) // ex: https://SEU_DOMINIO.com/api/partner_api.php
  checkout_url   String   @db.VarChar(500) // ex: https://pay.seudominio.com/checkout
  api_key        String   @db.VarChar(255)
  api_secret_enc String   @db.Text
  product_id     Int
  is_active      Boolean  @default(false)
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  @@index([is_active])
  @@index([product_id])
  @@map("mvm_pay_config")
}

// ============================================
// REGISTRATION TOKENS (MVM PAY ACTIVATION LINK)
// ============================================

model RegistrationToken {
  id         Int      @id @default(autoincrement())
  email      String   @db.VarChar(255)
  token_hash String   @unique @db.VarChar(64) // sha256 hex
  purpose    String   @default("MVM_PAY_ACTIVATION") @db.VarChar(50)
  expires_at DateTime
  used_at    DateTime?
  created_at DateTime @default(now())

  @@index([email])
  @@index([purpose])
  @@index([expires_at])
  @@map("registration_tokens")
}

// ============================================
// MVM PAY LOGS
// ============================================

model MvmPayLog {
  id           Int      @id @default(autoincrement())
  level        String   @default("INFO") @db.VarChar(10) // INFO | WARN | ERROR | DEBUG
  source       String   @db.VarChar(20) // API | SYNC | ADMIN | WEBHOOK
  action       String?  @db.VarChar(50) // request | response | sync_start | sync_end | error
  method       String?  @db.VarChar(10)
  path         String?  @db.VarChar(255)
  status_code  Int?
  duration_ms  Int?
  email        String?  @db.VarChar(255)
  request_json Json?    @db.Json
  response_json Json?   @db.Json
  error_message String? @db.Text
  created_at   DateTime @default(now())

  @@index([created_at])
  @@index([level])
  @@index([source])
  @@index([path])
  @@index([status_code])
  @@index([email])
  @@map("mvm_pay_logs")
}

// ============================================
// SYSTEM SETTINGS
// ============================================

model SystemSetting {
  id          Int      @id @default(autoincrement())
  key         String   @unique @db.VarChar(100)
  value       String   @db.Text
  description String?  @db.VarChar(255)
  category    String?  @db.VarChar(50) // 'payment', 'general', 'security', etc
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  updated_by  Int? // user_id que atualizou

  @@index([key])
  @@index([category])
  @@map("system_settings")
}

// ============================================
// SUBSCRIPTIONS
// ============================================

model SubscriptionPlan {
  id                    Int      @id @default(autoincrement())
  name                  String   @db.VarChar(255)
  description           String?  @db.Text
  price_monthly         Decimal  @db.Decimal(10, 2)
  price_quarterly       Decimal  @db.Decimal(10, 2)
  duration_days         Int      @default(30)
  is_active             Boolean  @default(true)
  features_json         Json?    @db.Json
  max_exchange_accounts Int?     // null = ilimitado, número = limite específico
  // IDs do plano no MvM Pay (um por período)
  mvm_pay_plan_id_monthly   Int?
  mvm_pay_plan_id_quarterly Int?
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt

  subscriptions Subscription[]

  @@index([is_active])
  @@index([mvm_pay_plan_id_monthly])
  @@index([mvm_pay_plan_id_quarterly])
  @@map("subscription_plans")
}

model Subscription {
  id                Int      @id @default(autoincrement())
  user_id           Int
  plan_id            Int
  status            String   @db.VarChar(50) // 'ACTIVE' | 'CANCELLED' | 'EXPIRED' | 'PENDING_PAYMENT'
  start_date        DateTime?
  end_date          DateTime?
  auto_renew        Boolean  @default(false)
  payment_method    String?  @db.VarChar(20) // 'CARD' | 'PIX'
  // Fonte de verdade para origem do provedor da assinatura
  // 'native' | 'mvm_pay' (pode ser estendido futuramente)
  origin_provider   String   @default("native") @db.VarChar(20)
  mp_payment_id     String?  @db.VarChar(255)
  mp_preference_id  String?  @db.VarChar(255)
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  user             User                @relation(fields: [user_id], references: [id], onDelete: Cascade)
  plan             SubscriptionPlan     @relation(fields: [plan_id], references: [id], onDelete: Restrict)
  payments         SubscriptionPayment[]

  @@index([user_id])
  @@index([plan_id])
  @@index([status])
  @@index([user_id, status])
  @@index([origin_provider])
  @@map("subscriptions")
}

model SubscriberProfile {
  id                      Int      @id @default(autoincrement())
  user_id                 Int      @unique
  cpf_enc                 String?  @db.Text // CPF criptografado
  birth_date              DateTime?
  address_street          String?  @db.VarChar(255)
  address_number          String?  @db.VarChar(20)
  address_complement      String?  @db.VarChar(100)
  address_neighborhood    String?  @db.VarChar(100)
  address_city            String?  @db.VarChar(100)
  address_state           String?  @db.VarChar(2)
  address_zipcode         String?  @db.VarChar(10)
  created_at              DateTime @default(now())
  updated_at              DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("subscriber_profiles")
}

model SubscriberParameters {
  id                        Int      @id @default(autoincrement())
  user_id                   Int      @unique
  default_exchange_account_id Int?
  quote_amount_fixed        Decimal? @db.Decimal(36, 18) // Valor escolhido pelo assinante
  max_orders_per_hour       Int?
  min_interval_sec          Int?
  default_order_type        String   @default("MARKET") @db.VarChar(20)
  slippage_bps              Int      @default(0)
  default_sl_enabled        Boolean  @default(false)
  default_sl_pct            Decimal? @db.Decimal(5, 2)
  default_tp_enabled        Boolean  @default(false)
  default_tp_pct            Decimal? @db.Decimal(5, 2)
  trailing_stop_enabled     Boolean  @default(false)
  trailing_distance_pct     Decimal? @db.Decimal(5, 2)
  min_profit_pct            Decimal? @db.Decimal(5, 2)
  created_at                DateTime @default(now())
  updated_at                DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("subscriber_parameters")
}

// Parametros padrao globais para todos os assinantes
model SubscriberDefaultParameters {
  id                         Int      @id @default(autoincrement())
  // Limites de valor da ordem
  min_quote_amount           Decimal  @default(20) @db.Decimal(36, 18)  // Minimo USD
  max_quote_amount           Decimal? @db.Decimal(36, 18)               // Maximo USD (null = sem limite)
  default_quote_amount       Decimal  @default(100) @db.Decimal(36, 18) // Valor padrao
  // Simbolos permitidos (separados por virgula, ex: "BTCUSDT,SOLUSDT,BNBUSDT")
  allowed_symbols            String?  @db.Text
  // SL/TP/SG/TSG padrao
  default_sl_enabled         Boolean  @default(false)
  default_sl_pct             Decimal? @db.Decimal(5, 2)
  default_tp_enabled         Boolean  @default(false)
  default_tp_pct             Decimal? @db.Decimal(5, 2)
  default_sg_enabled         Boolean  @default(false)
  default_sg_pct             Decimal? @db.Decimal(5, 2)
  default_sg_drop_pct        Decimal? @db.Decimal(5, 2)
  default_tsg_enabled        Boolean  @default(false)
  default_tsg_activation_pct Decimal? @db.Decimal(5, 2)
  default_tsg_drop_pct       Decimal? @db.Decimal(5, 2)
  min_profit_pct             Decimal? @db.Decimal(5, 2)
  // Configuracoes gerais
  lock_webhook_on_tsg        Boolean  @default(true)
  created_at                 DateTime @default(now())
  updated_at                 DateTime @updatedAt

  @@map("subscriber_default_parameters")
}

// ============================================
// CRYPTO SYMBOLS CACHE
// ============================================

model CryptoSymbol {
  id              Int       @id @default(autoincrement())
  symbol          String    @unique @db.VarChar(20)
  coingecko_id    String?   @db.VarChar(100)
  name            String?   @db.VarChar(255)
  logo_url        String?   @db.VarChar(500)
  logo_local_path String?   @db.VarChar(500)
  last_updated    DateTime?
  created_at      DateTime  @default(now())
  updated_at      DateTime  @updatedAt

  @@index([symbol])
  @@index([coingecko_id])
  @@map("crypto_symbols")
}

model SubscriptionPayment {
  id              Int      @id @default(autoincrement())
  subscription_id  Int?     // Opcional: só vinculado quando pagamento é aprovado
  mp_payment_id    String?  @db.VarChar(255)
  transfi_payment_id String? @db.VarChar(255)
  transfi_order_id  String? @db.VarChar(255)
  amount           Decimal  @db.Decimal(10, 2)
  status           String   @db.VarChar(50) // 'PENDING' | 'APPROVED' | 'REJECTED' | 'CANCELLED' | 'REFUNDED' | todos os status do MP
  payment_method   String   @db.VarChar(20) // 'CARD' | 'PIX' | 'CRYPTO'
  payer_cpf        String?  @db.VarChar(20) // CPF informado pelo usuário no pagamento
  payer_email      String?  @db.VarChar(255) // Email informado no pagamento
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  subscription Subscription? @relation(fields: [subscription_id], references: [id], onDelete: Cascade)

  @@index([subscription_id])
  @@index([mp_payment_id])
  @@index([transfi_payment_id])
  @@index([transfi_order_id])
  @@index([status])
  @@index([payer_email])
  @@map("subscription_payments")
}

model SubscriptionWebhookEvent {
  id                Int      @id @default(autoincrement())
  mp_event_id       String?  @db.VarChar(255)
  mp_event_type     String?  @db.VarChar(50)
  mp_resource_id    String?  @db.VarChar(255)
  raw_payload_json  Json?    @db.Json
  processed         Boolean  @default(false)
  processed_at      DateTime?
  created_at        DateTime @default(now())

  @@unique([mp_event_id])
  @@index([mp_resource_id])
  @@index([processed])
  @@index([created_at])
  @@map("subscription_webhook_events")
}

// ============================================
// TRANSFI WEBHOOK EVENTS
// ============================================

model TransFiWebhookEvent {
  id                Int      @id @default(autoincrement())
  transfi_event_id  String   @db.VarChar(255)
  transfi_event_type String  @db.VarChar(50)
  transfi_resource_id String  @db.VarChar(255)
  raw_payload_json  Json?    @db.Json
  processed         Boolean  @default(false)
  processed_at      DateTime?
  created_at        DateTime @default(now())

  @@unique([transfi_event_id])
  @@index([transfi_resource_id])
  @@index([processed])
  @@index([created_at])
  @@map("transfi_webhook_events")
}

// ============================================
// PASSKEYS (WEBAUTHN)
// ============================================

model Passkey {
  id            Int       @id @default(autoincrement())
  user_id       Int
  credential_id String    @unique @db.VarChar(500) // Base64URL do credential ID
  public_key    String    @db.Text // Public key em formato COSE
  counter       BigInt    @default(0) // Counter para prevenir replay attacks
  device_name   String?   @db.VarChar(255) // Nome do dispositivo (ex: "iPhone 15 Pro")
  transports    String?   @db.VarChar(255) // Transports suportados (usb, nfc, ble, internal)
  user_agent    String?   @db.Text
  last_used_at  DateTime?
  created_at    DateTime  @default(now())

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([credential_id])
  @@map("passkeys")
}

// Tabela para armazenar challenges temporários de passkey (necessário em ambientes multi-processo)
model PasskeyChallenge {
  id            Int       @id @default(autoincrement())
  challenge_key String    @unique @db.VarChar(255) // Chave única (ex: "reg_123" ou "auth_email@example.com")
  challenge     String    @db.Text // O challenge em si
  expires_at    DateTime  // Quando o challenge expira
  created_at    DateTime  @default(now())

  @@index([challenge_key])
  @@index([expires_at])
  @@map("passkey_challenges")
}

// ============================================
// USER SESSIONS (MULTIPLE DEVICES)
// ============================================

model UserSession {
  id               Int      @id @default(autoincrement())
  user_id          Int
  session_token    String   @unique @db.VarChar(500) // Token único da sessão
  refresh_token    String   @unique @db.VarChar(500) // Refresh token específico desta sessão
  device_name      String?  @db.VarChar(255)
  device_type      String?  @db.VarChar(50) // 'desktop' | 'mobile' | 'tablet'
  browser          String?  @db.VarChar(100) // Nome do browser
  os               String?  @db.VarChar(100) // Sistema operacional
  user_agent       String?  @db.Text
  ip_address       String?  @db.VarChar(45)
  remember_me      Boolean  @default(false)
  is_passkey_auth  Boolean  @default(false) // Se foi autenticado via passkey
  expires_at       DateTime
  last_activity_at DateTime @default(now())
  created_at       DateTime @default(now())

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([session_token])
  @@index([refresh_token])
  @@index([expires_at])
  @@map("user_sessions")
}

// ============================================
// WEB PUSH NOTIFICATIONS
// ============================================

model WebPushSubscription {
  id          Int      @id @default(autoincrement())
  user_id     Int
  endpoint    String   @db.Text // URL do serviço de push
  p256dh      String   @db.Text // Chave pública
  auth        String   @db.Text // Chave de autenticação
  user_agent  String?  @db.Text
  device_name String?  @db.VarChar(255)
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, endpoint(length: 500)])
  @@index([user_id])
  @@index([is_active])
  @@map("web_push_subscriptions")
}

// ============================================
// UNIFIED NOTIFICATION TEMPLATES
// ============================================

model NotificationTemplate {
  id             Int      @id @default(autoincrement())
  template_type  String   @db.VarChar(50) // 'WEBHOOK_RECEIVED', 'POSITION_OPENED', etc.
  name           String   @db.VarChar(255)
  channel        String   @db.VarChar(20) // 'whatsapp' | 'email' | 'webpush'
  subject        String?  @db.VarChar(255) // Para email/webpush (título)
  body           String   @db.Text // Corpo da mensagem (texto simples ou template)
  body_html      String?  @db.Text // Para email (HTML)
  icon_url       String?  @db.VarChar(500) // Para webpush (ícone)
  action_url     String?  @db.VarChar(500) // Para webpush (URL ao clicar)
  variables_json Json?    @db.Json // Variáveis disponíveis para este template
  is_active      Boolean  @default(true)
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  @@unique([template_type, channel])
  @@index([template_type, channel])
  @@index([is_active])
  @@map("notification_templates")
}

// ============================================
// WEB PUSH NOTIFICATION LOG
// ============================================

model WebPushNotificationLog {
  id               Int      @id @default(autoincrement())
  template_type    String   @db.VarChar(50)
  user_id          Int
  subscription_id  Int?
  title            String?  @db.VarChar(255)
  body             String?  @db.Text
  status           String   @db.VarChar(20) // 'sent' | 'failed' | 'clicked'
  error_message    String?  @db.Text
  webhook_event_id Int?
  position_id      Int?
  sent_at          DateTime @default(now())

  @@index([template_type])
  @@index([user_id])
  @@index([status])
  @@index([sent_at])
  @@map("web_push_notification_logs")
}
